package main

import "fmt"

func functions() {
	SayMessage("hello")

	// passing pointer to the function and if the function mutate the pointer pointed value, the value outside of the function is going to be mutated
	a := "Tina"
	b := "Hello"
	fmt.Println(a, b)
	Greetings(&a, &b)
	fmt.Println(a, b)

	// passing in pointer to function is very efficient and passing pointer for functions to act on a value outside of function

	// different parameters
	sum("the sum is", 1, 2, 3, 4, 5)
	sump("the sum is", 1, 2, 3, 4, 5)

	c := greeter{"hi", "Tina"}
	c.greet()
	c.greetpointer()
	fmt.Println(c.name)
}

func SayMessage(x string) {
	fmt.Println(x)
}

func Greetings(str1, str2 *string) {
	*str1 = "peter"
	fmt.Println(*str1, *str2)
}

// returning a value from the function
func sum(msg string, values ...int) int {
	fmt.Println(values)
	result := 0
	for _, v := range values {
		result += v
	}
	fmt.Println(result)
	return result
}

//returning a pointer to that value generated by the function
func sump(msg string, values ...int) *int {
	result := 0
	for _, v := range values {
		result += v
	}
	r := &result
	fmt.Println(*r)
	return r
}

// methods -  functions run on any type

type greeter struct {
	greeting string
	name     string
}

// value receiver methods - we are running the function on a copy of the value (greeter object)
func (c greeter) greet() {
	fmt.Println(c.greeting, c.name)
}

// pointer receiver methods

func (c *greeter) greetpointer() {
	fmt.Println(c.greeting, c.name)
	// mutate the greeter object outside of the function as the greeter passed in here is the pointer
	c.name = "Peter"
}

// when pointers are passed in the functions or methods, the function can change the value in the caller
// this is always true for data of slices and maps because they are passing by pointers under the hood.
